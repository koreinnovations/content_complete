<?php
// $Id$

/**
 * @file
 * Allows users with valid permissions to tag CCK fields
 * as required fields for the content to be considered complete.
 */

/**
 * Implementation of hook_perm().
 */
function content_complete_perm() {
  return array(
    'administer content complete', 
    'access content complete'
  );
}

/**
 * Implementation of hook_help().
 */
function content_complete_help($path, $arg) {
  switch ($path) {
    case 'admin/content/content_complete':
      return '<p>'. t('You can find more configuration options on the content type edit form of Content-Complete-enabled <a href="@content-types">content types</a>.', array('@content-types' => url('admin/content/types'))) .'</p>';
  }
}

/**
 * Implementation of hook_menu() 	 
 */ 	 
function content_complete_menu() { 	 
  $items['admin/content/content_complete'] = array( 	 
    'title' => 'Content Complete', 	 
    'description' => 'Tag CCK fields as required for percent complete handling.', 	 
    'page callback' => 'content_complete_admin_settings', 	 
    'access arguments' => array('administer content complete'), 	 
    'file' => 'content_complete.admin.inc' 	 
  );
  return $items; 	 
}

/**
 * Implementation of hook_block().
 * 
 * Show a configured block with completeness for the node. Note that this
 * can be achived in a more flexible way using the views integration.
 */
function content_complete_block($op = 'list', $delta = 0, $edit = array()) {  
  if (user_access('access content complete')) {
    switch ($op) {
      case 'list':
        $blocks = array();
        // Block for completeness of a specific node.
        $blocks['content_complete_node']['info'] = t('Content Complete: Node Completeness');
        return $blocks;
      case 'view':
        // TODO @hunvreus: handle permissions in the correct way (eg who can view complete edit links should be
        // together with who can edit nodes?)
        // Single node completeness (only displayed on full page view of the node)
        if ($delta == 'content_complete_node' && arg(0) == 'node' && is_numeric(arg(1))) {
          $node = menu_get_object();
          
          if (variable_get('content_complete_'. $node->type, 0)) {
            $complete = content_complete_get_data($node);
                      
            if (!empty($complete) && 
              ($complete['percent'] != 100 || ($complete['percent'] == 100 && !variable_get('content_complete_hide_complete', TRUE)))) {
              $block['subject'] = t('Node Completeness');
              $block['content'] = theme('content_complete_profile_percent_complete', $complete);
            }
          }
        }  
        return $block;
      case 'configure': 
        $form['content_complete_hide_block'] = array(
          '#title' => t('Hide the blocks when the percentage reaches 100%'),
          '#type' => 'checkbox',
          '#default_value' => variable_get('content_complete_hide_complete', TRUE),
          '#description' => t('If you disable this feature, the blocks will be shown even when 100% has been reached.'),
        );
        return $form;
      case 'save':
        variable_set('content_complete_hide_complete', $edit['content_complete_hide_block']);
        return;
    }
  }
}

/**
 * Implementation of hook_form_alter().
 * 
 * @see content_complete_node_type_delete_confirm_submit()
 * @see content_complete_content_field_remove_form_submit()
 */
function content_complete_form_alter(&$form, $form_state, $form_id) {
  // If a content type is deleted, delete also all its entries in the database; hook onto submit function
  if ($form_id == 'node_type_delete_confirm') {
    $form['#submit'][] = 'content_complete_node_type_delete_confirm_submit';
  }
  
  // If a field from a content type is deleted, delete the entry in the database; hook onto submit function
  if ($form_id == 'content_field_remove_form') {
    $form['#submit'][] = 'content_complete_content_field_remove_form_submit';
  }
  
  // Intercept all node edit forms and highlight field to be completed
  if (arg(2) == 'edit' && strpos($form_id, 'node_form') !== FALSE && $_GET['content_complete_fieldname'] != '') {
    $fieldname = $_GET['content_complete_fieldname'];
    form_set_error($fieldname, t('Please complete the fields.'));
  }
  
  // Content type settings form
  if ($form_id == 'node_type_form' && user_access('access content complete')) {
    $form['content_complete'] = array(
      '#type' => 'fieldset',
      '#title' => t('Content complete'),
      '#collapsible' => TRUE,
      '#collapsed' => TRUE,
    );
    
    $form['content_complete']['content_complete'] = array(
      '#type' => 'radios',
      '#title' => t('Completeness'),
      '#default_value' => variable_get('content_complete_'. $form['#node_type']->type, 0),
      '#options' => array(t('Disabled'), t('Enabled')),
      '#description' => t('Enable the completeness feature for that content type.'),
    );
    
    // Do we add a new content type, or do we modify an existing one?
    $type_exists = ($form['#node_type']->type) ? TRUE : FALSE;

    if ($type_exists) {
      $fields = content_complete_get_fields($form['#node_type']->type);
      
      $options = array();
      foreach ($fields as $field_name => $field_data) {
        $key = $field_name;
        $label = $field_data['label'] ." <span class='description'>". $field_name ."</span>";
        $options[$field_name] = $label;
      }

      $form['content_complete']['content_complete_fields'] = array(
        '#type' => 'checkboxes',
        '#title' => t('Fields'),
        '#default_value' => variable_get('content_complete_fields_'. $form['#node_type']->type, array()),
        '#options' => $options,
        '#description' => t('Select one or more fields for completeness.'),
      );
      
      // Warn the user that cache needs to be rebuilt after changing those values
      $form['content_complete']['warning_cache'] = array(
        '#prefix' => "<div class='warning'>",
        '#value' => t('Note that you need to <a href="@cache">rebuild your cache</a> after changing those values.', array('@cache' => url('admin/content/content_complete'))),        
        '#suffix' => "</div>",
      );
      
    } else {
      // Warn the user that no fields are available at the time of content type creation.
      $form['content_complete']['warning_new_type'] = array(
        '#prefix' => "<div class='warning'>",
        '#value' => t('You can only add fields to check for completeness after creating the content type and adding fields to it.'),
        '#suffix' => "</div>",
      ); 
    }
  }
}

/**
 * Submit function called when a node type is deleted. Remove the node type from
 * the content_complete table as well.
 * 
 * @see content_complete_form_alter()
 */
function content_complete_node_type_delete_confirm_submit($form, &$form_state) {
  if (isset($form['type']['#value'])) {
    $type = $form['type']['#value'];
    variable_del('content_complete_'. $type);
    variable_del('content_complete_fields_'. $type);
    db_query("DELETE FROM {content_complete} c INNER JOIN {node} n ON c.nid = n.nid WHERE n.type = '%s'", $type);
  }
}

/**
 * Submit function called when a CCK field is deleted. Remove the field from
 * the content_complete table as well.
 * 
 * @see content_complete_form_alter()
 */
function content_complete_content_field_remove_form_submit($form, &$form_state) {
  if (isset($form['type_name']['#value']) && isset($form['field_name']['#value'])) {
    $type = $form['type_name']['#value'];
    $field_name = $form['field_name']['#value'];
    $fields = variable_get('content_complete_fields_'. $type, array());
    for ($i = 0; $i < count(fields); $i++) {
      if ($fields[$i] == $field_name) unset($fields[$i]);
    }
    variable_get('content_complete_fields_'. $type, $fields);
    db_query("DELETE FROM {content_complete} c INNER JOIN {node} n ON c.nid = n.nid WHERE n.type = '%s'", $type);
  }
}

/**
 * Get the content complete percentage data for a given node or a whole content type.
 * 
 * TODO: refactor part of this code into the preprocess function, see theme.inc
 *
 * @see theme_content_complete_profile_percent_complete()
 * @param $node
 *   The node object to calculate completion for.
 * @return 
 *   An array of fields such as percentage complete, next field to be
 *   completed etc.
 */
function content_complete_get_data($node) {  
  $fields = content_complete_get_fields($node->type); // Grab all fields for that content type
  $tagged_fields = variable_get('content_complete_fields_'. $node->type, array()); // Fields tagged for completeness (can be empty)
  $fields_values = content_complete_get_fields_values($node); // Completed fields (can be empty)
    
  $percent = 0;
  $complete = 0;
  $incomplete = 0;
  $total = 0;
  $nextfield_set = FALSE;
  
  // Compare the two arrays and compute percentages etc.
  foreach ($tagged_fields as $key => $value) {
    if ($fields_values[$value] == '') { // Empty field
      if ($nextfield_set === FALSE) {
        $nextfield_set = TRUE;
        $nextfield = $fields[$value]['label'];
        $nextname = $value;
      }
    }
    else {
      $complete++;
    }
  }
  
  $dec = 0;
  if (count($tagged_fields)) {
    $dec = number_format(($complete / count($tagged_fields)), 2);
  }
  $percent = $dec * 100;
  if ($nextfield_set) {
    $next = number_format((($complete + 1) / count($tagged_fields)), 2);
    $nextpercent = $next * 100;
  }
  
  $incomplete = count($tagged_fields) - $complete;
  $total = count($tagged_fields);
  $nid = $fields_values['nid'];
  $type_names = node_get_types('names');
  
  // Divide percentages in 4 regions of 25 each
  $leq_percent=0;
  while ($leq_percent<=100) {
    if ($percent <= $leq_percent) break;
    $leq_percent+=25;
  }
  
  $data = array();
  $data['nid'] = $nid;
  $data['percent'] = $percent;
  $data['leq_percent'] = $leq_percent;
  $data['completed'] = $complete;
  $data['incomplete'] = $incomplete;
  $data['total'] = $total;
  $data['nextfield'] = t($nextfield);
  $data['nextpercent'] = $nextpercent;
  $data['nextname'] = $nextname;
  $data['type'] = $node->type;
  
  // Put human readble name.
  if (module_exists('i18ncontent')) {
    $data['name'] = tt("nodetype:type:$node->type:name", $type_names[$node->type]);
  }
  else {
    $data['name'] = $type_names[$node->type];
  }
  
  // See who has edit permissions, depending on this we show/hide the edit links
  global $user;
  if (user_access('edit any '. $node->type .' content') || 
     (user_access('edit own '. $node->type .' content') && $node->uid == $user->uid)) {
    $data['edit'] = TRUE;
  } else {
    $data['edit'] = FALSE;
  }
  
  // Update the cache.
  content_complete_update_cache($node, $data);
    
  return $data;
}

/**
 * Implementation of hook_nodeapi().
 */
function content_complete_nodeapi(&$node, $op, $a3 = NULL, $a4 = NULL) {
  if (variable_get('content_complete_'. $node->type, 0)) {
    switch ($op) {
      case 'insert':
      case 'update':
        // Recalculate the cache
        db_query('DELETE FROM {content_complete} WHERE nid = %d', $node->nid);
        content_complete_get_data($node);
        break;

      case 'delete':
        // Remove the cache
        db_query('DELETE FROM {content_complete} WHERE nid = %d', $node->nid);
        break;
    }
  }
}

/**
 * Clear the cache.
 */
function content_complete_clear_cache() {
  db_query("DELETE FROM {content_complete}");
}

/**
 * Update the cache.
 * 
 * @param $node The node to update the cache for
 * @param $data The completeness data for this node
 */
function content_complete_update_cache(&$node, &$data) {  
  $completeness = db_result(db_query('SELECT completeness FROM {content_complete} WHERE nid = %d', $node->nid));
  // If there is no cache we build it
  if (empty($completeness)) {
    db_query('INSERT INTO {content_complete} SET nid = %d, completeness = %d', $node->nid, $data['percent']);
  } 
  elseif ($completeness != $data['percent']) {
    db_query('UPDATE {content_complete} SET completeness = %d WHERE nid = %d', $data['percent'], $node->nid);
  }
}

/**
 * Get all content types that have been tagged.
 * 
 * @return
 *   Array of content types.
 */
function content_complete_get_enabled_types() {
  $types = node_get_types('names');
  $tagged_types = array();
  foreach ($types as $type => $name) {
    if (variable_get('content_complete_'. $type, 0)) {
     $tagged_types[$type] = $name;
    }
  }
  return $tagged_types;
}

/**
 * Determine if a given node type is a content complete node type.
 * 
 * @param $type
 *   The node object or the node's type
 */
function content_complete_enabled_type($type) {
  if (is_object($type)) {
    $type = $type->type;
  }
  return variable_get('content_complete_'. $type, 0);
}

/**
 * Get all the CCK fields that have been completed.
 *
 * @param $content_type
 *   The machine-readable name of the content type.
 * @return 
 *   Array of nodes with each node being an array of fields with their values.
 */
function content_complete_get_fields_values($node) {
  $fields = content_complete_get_fields($node->type); // Grab all fields for the node's content type
  
  // We then build an array of the node fields values
  $node_fields = array();
  foreach ($fields as $field_name => $field_data) {
    if (isset($node->{$field_name})) {
      
      $raw = $node->{$field_name};
      $value = $raw;
      
      if (isset($field_data['module'])) { // This is a CCK field
        // We check for emptiness using the CCK hook hook_content_is_empty
        $function = $field_data['module'] .'_content_is_empty';
        if (!isset($raw[0])) {
          $value = '';
        }
        elseif (!$function($raw[0], $field_name)) {
          $value = 'cck'; // A dummy value to flag this field has been set
        } 
        else {
          $value = ''; // Field not set
        }
      }
      elseif ($field_name == 'files') { // Core node files field
        if (empty($raw)) {
          $value = '';
        }
        else {
          $value = 'files';
        }
      }
      
      $node_fields[$field_name] = $value;
    }
  }
  
  if (count($node_fields)) {
    $node_fields['nid'] = $node->nid; 
  }
  
  return $node_fields;
}

/**
 * Get all the fields that should be always ignored in completion checks.
 * 
 * @return
 *   Array of ignored fields. 
 */
function content_complete_get_ignore_fields() {
  $ignore = array(
    'menu' 
  );
  return $ignore;
}

/**
 * Get all the fields of this content type that could be checked for completion.
 * 
 * A label tag is added for the human-readable description of the field.
 * 
 * @param $content_type
 *   The machine-readable name of the content type.
 * @return
 *   Array assoc of fields with field data.
 */
function content_complete_get_fields($content_type) {
  $types = content_types();
  $type = $types[$content_type];
  $ignore = content_complete_get_ignore_fields();
  $fields = array();
  
  /**
   * Add default fields such as node title and body 
   * that do not belong to CCK but might be checked anyway.
   * 
   * If a field has the 'view' parameter set we need to add that one instead of the key
   * of the array (for example, it is 'body' instead of 'body_field')
   */
  foreach ($type['extra'] as $code => $data) {
    if (! in_array($code, $ignore)) {
      if (isset($data['view'])) {
        $key = $data['view'];
      } 
      else {
        $key = $code;
      }
      $fields[$key] = $data;
    }
  }
  
  /**
   * Add custom CCK fields
   */
  foreach ($type['fields'] as $code => $data) {
    if (! in_array($code, $ignore)) {
      $label = (isset($data['widget']['label'])) ? $data['widget']['label'] : $code;
      $data['label'] = $label;
      $fields[$code] = $data;
    }
  }
  
  return $fields;
}

/**
 * Implementation of hook_theme(). 
 */
function content_complete_theme() {
  $path = drupal_get_path('module', 'content_complete') .'/theme';
  return array(
    'content_complete_profile_percent_complete' => array(
      'arguments' => array('complete' => NULL),
      'file' => 'theme.inc',
      'path' => $path,
    ),
  );
}

/**
 * Implementation of hook_views_api().
 */
function content_complete_views_api() {
  return array(
    'api' => 2,
    'path' => drupal_get_path('module', 'content_complete') .'/views',
  );
}